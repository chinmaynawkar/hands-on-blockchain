/**
 * Zero-Knowledge Proof Protocol Implementation
 * Demonstrates "Password Knowledge Proof" using SHA-256 hashing
 *
 * Protocol Flow:
 * 1. Shared secret agreement (both parties know the secret)
 * 2. Prover generates commitment = hash(secret + nonce)
 * 3. Verifier generates random challenge
 * 4. Prover generates response = (secret_value + nonce_value) % challenge_value
 * 5. Verifier validates proof without learning the secret
 */

/**
 * Convert string to numeric value for mathematical operations
 * Uses simple character code summation for educational purposes
 */
function stringToNumber(str) {
  let sum = 0;
  for (let i = 0; i < str.length; i++) {
    sum += str.charCodeAt(i) * (i + 1); // Weight by position to avoid simple permutations
  }
  return sum;
}

/**
 * Generate SHA-256 hash using browser's SubtleCrypto API
 */
async function generateHash(input) {
  const encoder = new TextEncoder();
  const data = encoder.encode(input);
  const hashBuffer = await crypto.subtle.digest("SHA-256", data);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  return hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
}

/**
 * Generate cryptographically secure random number
 */
function generateSecureRandom(min = 1000, max = 9999) {
  const range = max - min + 1;
  const randomArray = new Uint32Array(1);
  crypto.getRandomValues(randomArray);
  return min + (randomArray[0] % range);
}

/**
 * ZKP Protocol Class implementing the Password Knowledge Proof
 */
export class ZKPProtocol {
  constructor() {
    this.reset();
  }

  reset() {
    this.sharedSecret = "";
    this.proverNonce = null;
    this.commitment = "";
    this.challenge = null;
    this.response = null;
    this.isProofValid = null;
    this.steps = {
      secretSetup: false,
      commitment: false,
      challenge: false,
      response: false,
      verification: false,
    };
  }

  /**
   * Step 1: Setup shared secret (both prover and verifier agree on this)
   */
  setupSharedSecret(secret) {
    if (!secret || secret.trim().length === 0) {
      throw new Error("Secret cannot be empty");
    }

    this.sharedSecret = secret.trim();
    this.steps.secretSetup = true;
    return {
      success: true,
      message: "Shared secret established securely",
      secret: this.sharedSecret,
    };
  }

  /**
   * Step 2: Prover generates commitment
   * Commitment = hash(secret + nonce)
   */
  async generateCommitment() {
    if (!this.steps.secretSetup) {
      throw new Error("Must setup shared secret first");
    }

    // Generate random nonce for this proof session
    this.proverNonce = generateSecureRandom(10000, 99999);

    // Create commitment by hashing secret + nonce
    const commitmentInput = this.sharedSecret + this.proverNonce.toString();
    this.commitment = await generateHash(commitmentInput);

    this.steps.commitment = true;

    return {
      success: true,
      commitment: this.commitment,
      nonce: this.proverNonce, // In real ZKP, nonce would be kept secret until response phase
      message: "Commitment generated successfully",
    };
  }

  /**
   * Step 3: Verifier generates random challenge
   */
  generateChallenge() {
    if (!this.steps.commitment) {
      throw new Error("Must generate commitment first");
    }

    this.challenge = generateSecureRandom(100, 999);
    this.steps.challenge = true;

    return {
      success: true,
      challenge: this.challenge,
      message: "Random challenge generated by verifier",
    };
  }

  /**
   * Step 4: Prover generates response
   * Response = (secret_value + nonce_value) % challenge_value
   */
  generateResponse(simulateFailure = false) {
    if (!this.steps.challenge) {
      throw new Error("Must receive challenge first");
    }

    const secretValue = stringToNumber(this.sharedSecret);
    const nonceValue = this.proverNonce;
    const challengeValue = this.challenge;

    // Calculate response using modular arithmetic
    let calculatedResponse = (secretValue + nonceValue) % challengeValue;

    // For demonstration: simulate a wrong proof
    if (simulateFailure) {
      calculatedResponse = (calculatedResponse + 1) % challengeValue; // Intentionally wrong
    }

    this.response = calculatedResponse;
    this.steps.response = true;

    return {
      success: true,
      response: this.response,
      calculation: {
        secretValue: secretValue,
        nonceValue: nonceValue,
        challengeValue: challengeValue,
        formula: simulateFailure
          ? `(${secretValue} + ${nonceValue}) % ${challengeValue} + 1 = ${this.response} (WRONG)`
          : `(${secretValue} + ${nonceValue}) % ${challengeValue} = ${this.response}`,
      },
      message: simulateFailure
        ? "Response calculated with intentional error (for demo)"
        : "Response calculated successfully",
      isIntentionallyWrong: simulateFailure,
    };
  }

  /**
   * Step 5: Verifier validates the proof
   * Verification without learning the secret
   */
  async verifyProof() {
    console.log("üöÄ VERIFY PROOF CALLED!");
    console.log("üîç Steps check:", this.steps.response);

    if (!this.steps.response) {
      console.log("‚ùå Error: Must receive response first");
      throw new Error("Must receive response first");
    }

    try {
      console.log("‚úÖ Starting verification process...");
      const secretValue = stringToNumber(this.sharedSecret);

      console.log("üîç Starting ZKP Verification:");
      console.log("Secret Value:", secretValue);
      console.log("Prover Nonce:", this.proverNonce);
      console.log("Challenge:", this.challenge);
      console.log("Response:", this.response);

      // Calculate what the correct response should be
      const expectedResponse =
        (secretValue + this.proverNonce) % this.challenge;
      console.log("Expected Response:", expectedResponse);

      // Manual calculation verification
      console.log("üßÆ Manual Calculation Check:");
      console.log(`  stringToNumber('${this.sharedSecret}') = ${secretValue}`);
      console.log(
        `  (${secretValue} + ${this.proverNonce}) % ${this.challenge}`
      );
      console.log(`  = ${secretValue + this.proverNonce} % ${this.challenge}`);
      console.log(`  = ${expectedResponse}`);
      console.log(`  Actual response: ${this.response}`);
      console.log(`  Match: ${this.response === expectedResponse}`);

      // Method 1: Direct verification (for educational purposes)
      // In a real ZKP, we wouldn't know the prover's nonce
      const directVerification = this.response === expectedResponse;
      console.log("Direct Response Check:", directVerification);

      // Method 2: Try to find ANY valid nonce that produces this response
      // This simulates the real ZKP verification process
      let foundValidNonce = false;
      let reconstructedNonce = null;

      // Search for a nonce in our valid range that produces the given response
      for (let testNonce = 10000; testNonce <= 99999; testNonce++) {
        const testResponse = (secretValue + testNonce) % this.challenge;
        if (testResponse === this.response) {
          reconstructedNonce = testNonce;
          foundValidNonce = true;
          console.log("‚úÖ Found valid nonce:", testNonce);
          console.log("Matches actual nonce:", testNonce === this.proverNonce);
          break;
        }
      }

      if (!foundValidNonce) {
        console.log("‚ùå No valid nonce found!");
        this.isProofValid = false;
        this.steps.verification = true;
        return {
          success: true,
          isValid: false,
          message: "Proof verification failed - invalid response",
        };
      }

      // Method 3: Verify the commitment using the reconstructed nonce
      const expectedCommitmentInput =
        this.sharedSecret + reconstructedNonce.toString();
      const expectedCommitment = await generateHash(expectedCommitmentInput);
      const commitmentMatches = expectedCommitment === this.commitment;

      console.log("üîê Commitment Verification:");
      console.log("Expected input:", expectedCommitmentInput);
      console.log("Expected hash:", expectedCommitment);
      console.log("Actual commitment:", this.commitment);
      console.log("Commitments match:", commitmentMatches);

      // Final verification result
      this.isProofValid = commitmentMatches;
      this.steps.verification = true;

      console.log("üéØ Final Verification Results:");
      console.log("  foundValidNonce:", foundValidNonce);
      console.log("  commitmentMatches:", commitmentMatches);
      console.log("  FINAL isProofValid:", this.isProofValid);
      console.log("  Result:", this.isProofValid ? "VALID" : "INVALID");

      const result = {
        success: true,
        isValid: this.isProofValid,
        reconstructedNonce: reconstructedNonce,
        expectedCommitment: expectedCommitment,
        actualCommitment: this.commitment,
        verification: {
          responseValid: foundValidNonce,
          commitmentMatch: commitmentMatches,
          nonceFound: reconstructedNonce !== null,
          actualNonce: this.proverNonce,
          reconstructedNonceCorrect: reconstructedNonce === this.proverNonce,
        },
        message: this.isProofValid
          ? "Proof verified successfully! Prover knows the secret."
          : "Proof verification failed - commitment doesn't match!",
      };

      console.log("üì§ Returning result:", result);
      return result;
    } catch (error) {
      console.error("‚ùå Verification error:", error);
      console.error("‚ùå Error stack:", error.stack);
      this.isProofValid = false;
      this.steps.verification = true;
      const errorResult = {
        success: true,
        isValid: false,
        message: `Verification failed: ${error.message}`,
      };
      console.log("üì§ Returning error result:", errorResult);
      return errorResult;
    }
  }

  /**
   * Get current protocol state for UI display
   */
  getState() {
    return {
      sharedSecret: this.sharedSecret,
      proverNonce: this.proverNonce,
      commitment: this.commitment,
      challenge: this.challenge,
      response: this.response,
      isProofValid: this.isProofValid,
      steps: { ...this.steps },
    };
  }

  /**
   * Get educational explanation for current step
   */
  getStepExplanation(step) {
    const explanations = {
      secretSetup: {
        title: "Shared Secret Setup",
        description:
          "Both prover and verifier agree on a secret password. In real-world applications, only the prover would know this secret.",
        zkpProperty:
          "Soundness - The protocol must ensure that only someone who knows the secret can generate valid proofs.",
      },
      commitment: {
        title: "Commitment Generation",
        description:
          "The prover creates a cryptographic commitment by hashing the secret with a random nonce. This hides the secret while binding the prover to a specific value.",
        zkpProperty:
          "Hiding - The commitment reveals no information about the secret to outside observers.",
      },
      challenge: {
        title: "Challenge Generation",
        description:
          "The verifier generates a random challenge to ensure the prover cannot pre-compute responses. This randomness is crucial for security.",
        zkpProperty:
          "Zero-Knowledge - The randomness ensures that the verifier learns nothing beyond the validity of the statement.",
      },
      response: {
        title: "Response Calculation",
        description:
          "The prover uses the secret, nonce, and challenge to calculate a response. The mathematical relationship allows verification without revealing the secret.",
        zkpProperty:
          "Completeness - If the prover knows the secret, they can always generate a valid response.",
      },
      verification: {
        title: "Proof Verification",
        description:
          "The verifier checks if the response is consistent with the commitment and challenge, confirming the prover knows the secret without learning it.",
        zkpProperty:
          "Verification - The protocol allows anyone to verify the proof's validity without learning the secret.",
      },
    };

    return (
      explanations[step] || {
        title: "Unknown Step",
        description: "",
        zkpProperty: "",
      }
    );
  }
}
